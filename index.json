{
  "sports-data/basic_concepts/pull_api.html": {
    "href": "sports-data/basic_concepts/pull_api.html",
    "title": "Pull API | SBTech API",
    "keywords": "Pull API The Pull API should be used to query data, to retrieve an initial snapshot of data. For defining a query the API use OData as a query format (more info about OData supports you can find here). With Pull API you can build complex OData query since it supports operators like: Top, Skip, OrderBy which is not supported in Push API. Any OData query should be URL encoded before being sent. Note that we will not encode the samples in this documentation to improve readability, but you should remember to do it consistently in your code. URL path structure: GET /api/sportsdata/v2/{entity}/?query=...&locale=... Possible entities: events markets selections sports leagues regions Parameters: query (mandatory) - target OData query. Here is a list of supported OData operators: $filter - allows clients to filter a collection of resources that are addressed by a request URL. $top - number of items in the queried collection to be included in the result. $skip - number of items in the queried collection that are to be skipped and not included in the result. $orderBy - allows clients to request resources in either ascending order using asc or descending order using desc. from (optional) timeRange (optional) includeMarkets (optional) - additional OData query parameter to include markets for events ( could be used only for Events endpoint) . locale (optional) - let you specify locale to get translated response. projection (optional) - let you specify what model view to return: onlyId - returns only id default - returns default contract details - returns full contract Limitations: $top 100 is max value - the Pull API can't return more than 100 elements in one request. Defaults: if locale is not specified, the API will use \"en\". if $top operator is not specified, the API set 100 if $orderBy operator is not specified, the API applies default order for specific entity (more info about possible order you can find here) . If asc or desc not specified, then the resources will be ordered in ascending order. if projection is not specified, the API will use \"default\" Accepting formats: JSON (application/json) - is a default format which API is using if Accept header is omitted. MsgPack - (application/msgpack) - is an efficient binary serialization format. It's faster and smaller than JSON and we encourage you use it for production purposes. Accepting encodings: gzip lz4 - fast compression algorithm (can be used only for MsgPack) Examples: Let's try to query Events endpoint GET /api/sportsdata/v2/events?query=$filter=sportId eq '1' and isLive eq true&$orderBy=startEventDate&locale=en Accept: application/json Accept-Encoding: gzip Authorization: Bearer {JWT token} The response will provide the current snapshot of the targeted data. { \"data\": { \"events\": [{...}, {...}, {...}, {...}, {...}, {...}, {...}, {...}], \"markets\": [{...}, {...}, {...}, {...}, {...}, {...}, {...}, {...}] } }"
  },
  "sports-data/index.html": {
    "href": "sports-data/index.html",
    "title": "Introduction | SBTech API",
    "keywords": "Introduction The Sports Data is a push-based queriable API . You compose a query to target a specific data set and the API creates a Subscription and starts sending updates as they happen. For defining a query the API use OData as a query format (more info about OData supports you can find here) . The API supports these protocols: HTTP (for pull, to query data) SSE (for push, to subscribe and listen to a stream of updates, it works over HTTP). Logically the API is divided into two parts: Pull and Push. The Pull API should be used to query data, to retrieve an initial snapshot of data. The Push API should be used to subscribe on a stream of updates by a specific query. The Sports Data API is a way for our clients to build great real-time user experiences, specifically tailored for their needs. The API provides five endpoints returning five types of objects covering different levels of the offer hierarchy: Sports Leagues Events Markets Regions Objects come with a comprehensive amount of attributes describing all of their significant features and parameter. Based on these, you can build a wide range of presentations and experiences. Some examples of features which can be built using the Sports data API include various navigational widgets, league coupons presenting all events from a league, full live betting section, live betting schedule, event view for both pre-match and in-play events, list of upcoming events, optionally grouped by sport, league etc., list of most popular events (ordered by total amount of stakes or total number of bets) and many more. In short, we aim to provide support for any use case which can be part of a complete user-facing sportsbook solution. Usage of Sports Data API is a subject to a contractual agreement between SBTech and a partnering organization. Authentication is required for the API to be used in development and production environments."
  },
  "sports-data/querying_data/odata_query.html": {
    "href": "sports-data/querying_data/odata_query.html",
    "title": "OData query | SBTech API",
    "keywords": "OData query A query is part of a URL that is used to request specific data. We use OData query format (not protocol) with some limitations and enhancements, as described below. The OData query format represents a composition of several standard and custom query options. Usually you will work with: $filter, $orderby, $top, $skip query operators // OData query format $filter={expression}&$top={int}&$skip={int}&$orderBy={expression} // a very basic query to get live games /events?query=$filter=islive eq true // an example where we compose: $filter, $orderby and $top query operators /events?query=$filter=sportId eq '6' and isLive eq true&$orderby=startEventDate&$top=100 Any OData query should be URL encoded before being sent. Note that we will not encode the samples in this documentation to improve readability, but you should remember to do it consistently in your code. $filter=islive eq true // OData query without URL encoding %24filter%3Dislive%20eq%20true // OData query with URL encoding The Sports Data TypeScript client will provide this encoding out of the box, if you use it in your implementation. Many HTTP libraries also have this option. $filter operator Allows clients to filter a collection of resources that are addressed by a request URL. $filter supports following options Operator Description Example eq Equal (==) $filter=sportId eq '1' ne Not equal (!=) $filter=sportId ne '1' lt Less than (<) - le Less than or equal (<=) - gt Greater than (>) - ge Greater than or equal (>=) - and Logical and (&&) $filter=sportId eq '1' and leagueId eq '13761' or Logical or (||) $filter=sportId eq '1' or sportId eq '5' $top operator Allows requesting a specific number of top results to be included in the result. $filter=sportId eq '1'&$top=4 $skip operator Allows requesting a number of items to be skipped and not included in the result. $filter=sportId eq '1'&$top=10&$skip=10 $orderby operator Allows requesting resources in either ascending or descending order (asc or desc, respectively). If asc or desc is not specified, then the resources will be ordered in ascending order. $filter=(isLive eq false) and sportId eq '6'&top=10&$orderby=totalBets desc lamda operator Allows to express filters (any or all) based on the contents of a collection. // filter events which has value 'Streaming' in Tags array. $filter=Tags/any(x: x eq 'Streaming') querying by a nested property OData allows querying by a nested property. This means that you can filter a list of entities based on a property of an object, which is itself as a value for a property of the main entity. /markets?query=$filter=marketType/id eq '1_39'"
  },
  "sports-data/basic_concepts/push_api.html": {
    "href": "sports-data/basic_concepts/push_api.html",
    "title": "Push API | SBTech API",
    "keywords": "Push API The Push API should be used to create a subscription based on query and listen on updates. For defining a query the API use OData as a query format (more info about OData supports you can find here). In addition to creating a subscription you also can retrieve initial data and then subscribe on updates in one request, you will find more info about this in the last section. The main difference in terms of querying between Pull API and Push API is that in Push API the query is limited to $filter only, you can send the only $filter which is a query without $top, $skip, $orderBy operators. Any OData query should be URL encoded before being sent. Note that we will not encode the samples in this documentation to improve readability, but you should remember to do it consistently in your code. URL path structure: GET /api/sportsdata/v2/stream/{entity}/?query=...&locale=... Possible entities: events markets selections sports leagues regions Parameters: query (mandatory) - target OData filter. Here is a list of supported OData operators: $filter - allows clients to filter a collection of resources that are addressed by a request URL. from (optional) timeRange (optional) includeMarkets (optional) - additional OData query parameter to include markets for events ( could be used only for Events endpoint) . initialData - let you get initial snapshot with subscription in one request. locale (optional) - let you specify locale to get translated response. projection (optional) - let you specify what model view to return: onlyId - returns only id default - returns default contract details - returns full contract Limitations: in case if initialData=true the Push API can't return more than 100 elements in one request. Defaults: if locale is not specified, the API will use \"en\". if projection is not specified, the API will use \"default\" Accepting formats: SSE (text/event-stream) - is enabling a browser to receive automatic updates from a server via HTTP connection JSON (application/json) - is a default format which API is using if Accept header is omitted. MsgPack - (application/msgpack) - is an efficient binary serialization format. It's faster and smaller than JSON and we encourage you use it for production purposes. Accepting encodings: gzip lz4 - fast compression algorithm (can be used only for MsgPack) Examples: Let's try to subscribe on Events endpoint GET /api/sportsdata/v2/stream/events?query=$filter=sportId eq '1' and isLive eq true&locale=en Accept: text/event-stream, application/json Accept-Encoding: gzip Authorization: Bearer {JWT token} After establishing the subscription you will start receiving updates. The response will provide the list of collections: add, remove, change. { data: { add: { events: [], markets: [] }, remove: { events: [\"id1\", \"id2\"], markets: [\"id1\", \"id2\"] }, change: { events: [], markets: [] } } }"
  },
  "lookup/index.html": {
    "href": "lookup/index.html",
    "title": "PLACEHOLDER | SBTech API",
    "keywords": "PLACEHOLDER TODO: Add .NET projects to the src folder and run docfx to generate REAL API Documentation !"
  },
  "sports-data/querying_data/time_range_queries.html": {
    "href": "sports-data/querying_data/time_range_queries.html",
    "title": "Time range queries | SBTech API",
    "keywords": "Time range queries The Sports Data API supports defining a time range queries via two HTTP query parameters: from - it allows limiting the response by specifying the minimum start date. timeRange - it allows limiting the response by specifying a time range. /events?query=...&from=...&timeRange=... from (query parameter) it allows limiting the response by specifying the minimum start date of the events. For the events and markets collections, this is straightforward and acts as a filter based on the startDate or startEventDate properties. For leagues, regions and sports it will return only items which are referred by events with start date after the one specified here. This option is valid only when used together with timeRange, otherwise it will have no effect. If left empty, from is assumed to be equal to now, i.e. is dynamic and the time range will be considered to be floating. Alternatively, it accepts a value in ISO 8601 format. We also ignore any time granularity below hours (i.e. if you specify a time like 15:35, we will assume it to equal 15:00 // will return leagues from Soccer which have events // starting during the weekend of Sep 23-24, 2017, // assuming we want to display them to a client using CEST. /leagues?query=...&from=2017-09-23T02:00:00Z&timeRange=OneDay timeRange (query parameter) it allows limiting the response by specifying a time range for the start time of the affected events. For the events and markets collections, this is straightforward and acts as a filter based on the startDate or startEventDate properties. For leagues, regions and sports it will return only items which are referred by events with start date within the specified range. This option supports the following values: OneHour, TwoHours, ThreeHours, SixHours, TwelveHours, OneDay, TwoDays, ThreeDays, SevenDays. // will return leagues from Soccer which have events // starting within a range of two days from now. // note that this range is dynamic and the query will update, // dropping some events from the response and adding others, as the time passes. /leagues?query=...&timeRange=SevenDays"
  },
  "search/index.html": {
    "href": "search/index.html",
    "title": "PLACEHOLDER | SBTech API",
    "keywords": "PLACEHOLDER TODO: Add .NET projects to the src folder and run docfx to generate REAL API Documentation !"
  },
  "sports-data/querying_data/projections.html": {
    "href": "sports-data/querying_data/projections.html",
    "title": "Projections | SBTech API",
    "keywords": "Projections"
  },
  "index.html": {
    "href": "index.html",
    "title": "| SBTech API",
    "keywords": "SBTech has an industry-leading sports betting offer covering more than 55 sports, with 20,000+ events offered for in-play betting per month. Along with providing fully or semi-managed solutions, we ensure our operators have a high degree of control over the trading parameters, including unique pricing and operator level risk management. The pages in this wiki are intended to provide information on the specifics of the Sports Data API. Site operators and developers will gain a perspective of how to utilise it to build a full end-user facing sports application using SBTech as their sports betting provider. More specifically, we will focus on: How to setup and authenticate to start developing and running applications How to build queries and subscribe for updates How to read the response payload How to interpret the structure of the entities and their parameters"
  }
}